<?xml version="1.0"?>
<ruleset name="AlibabaJavaConcurrent"
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">

    <rule name="ThreadPoolCreationRule"
          language="java"
          since="1.6"
          message="线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。"
          class="com.alibaba.p3c.pmd.lang.java.rule.concurrent.ThreadPoolCreationRule">
        <description>
            <![CDATA[
说明：Executors各个方法的弊端：
1）newFixedThreadPool和newSingleThreadExecutor:
  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。
2）newCachedThreadPool和newScheduledThreadPool:
  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。
            ]]>
        </description>
        <priority>1</priority>
        <example>
            <![CDATA[
正例1：
    //org.apache.commons.lang3.concurrent.BasicThreadFactory
    ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,
        new BasicThreadFactory.Builder().namingPattern("example-schedule-pool-%d").daemon(true).build());
       ]]>
        </example>
        <example>
            <![CDATA[
正例2：
    ThreadPoolTaskExecutor userThreadPool = new ThreadPoolTaskExecutor();
    userThreadPool.setCorePoolSize(20);
    userThreadPool.setMaxPoolSize(3000);
    userThreadPool.setKeepAliveSeconds(0);
    userThreadPool.setQueueCapacity(100);
       ]]>
        </example>
        <example>
            <![CDATA[
正例3：
    <bean id="userThreadPool"
        class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
        <property name="corePoolSize" value="10" />
        <property name="maxPoolSize" value="100" />
        <property name="queueCapacity" value="2000" />
        <property name="rejectedExecutionHandler">
            <ref local="rejectedExecutionHandler" />
        </property>
    </bean>
       ]]>
        </example>
    </rule>
    <rule name="AvoidUseTimerRule"
          language="java"
          since="1.6"
          message="多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。"
          class="com.alibaba.p3c.pmd.lang.java.rule.concurrent.AvoidUseTimerRule">
        <description>
            <![CDATA[
多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。
反例：阿里云平台产品技术部，域名更新具体产品信息保存到tair，Timer产生了RunTimeExcetion异常后，定时任务不再执行，通过检查日志发现原因，改为ScheduledExecutorService方式。
       ]]>
        </description>
        <priority>1</priority>
        <example>
            <![CDATA[
    //org.apache.commons.lang3.concurrent.BasicThreadFactory
    ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,
            new BasicThreadFactory.Builder().namingPattern("example-schedule-pool-%d").daemon(true).build());
    executorService.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            //do something
        }
    },initialDelay,period, TimeUnit.HOURS);
       ]]>
        </example>
    </rule>
    <rule name="AvoidManuallyCreateThreadRule"
          language="java"
          since="1.6"
          message="线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。"
          dfa="true"
          class="com.alibaba.p3c.pmd.lang.java.rule.concurrent.AvoidManuallyCreateThreadRule">
        <description>
            <![CDATA[
线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。
       ]]>
        </description>
        <priority>1</priority>
    </rule>
    <rule name="ThreadShouldSetNameRule"
          language="java"
          since="1.6"
          message="创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"
          dfa="true"
          class="com.alibaba.p3c.pmd.lang.java.rule.concurrent.ThreadShouldSetNameRule">
        <description>
            <![CDATA[
创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。
       ]]>
        </description>
        <priority>1</priority>
        <example>
            <![CDATA[
    public class TimerTaskThread extends Thread {
        public TimerTaskThread(){
        super.setName("TimerTaskThread"); …
    }
       ]]>
        </example>
    </rule>
    <rule name="AvoidCallStaticSimpleDateFormatRule"
          language="java"
          since="1.6"
          message="SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。"
          dfa="true"
          class="com.alibaba.p3c.pmd.lang.java.rule.concurrent.AvoidCallStaticSimpleDateFormatRule">
        <description>
            <![CDATA[
SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。
说明：如果是JDK8的应用，可以使用instant代替Date，Localdatetime代替Calendar，Datetimeformatter代替Simpledateformatter，官方给出的解释：simple beautiful strong immutable thread-safe
       ]]>
        </description>

        <example>
            <![CDATA[
正例1：
    private static final String FORMAT = "yyyy-MM-dd HH:mm:ss";
    public String getFormat(Date date){
        SimpleDateFormat dateFormat = new SimpleDateFormat(FORMAT);
        return sdf.format(date);
    }
        ]]>
        </example>
        <example>
            <![CDATA[
正例2：
    private static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    public void getFormat(){
        synchronized (sdf){
        sdf.format(new Date());
        ….;
    }
        ]]>
        </example>
        <example>
            <![CDATA[
正例3：
    private static final ThreadLocal<DateFormat> DATE_FORMATTER = new ThreadLocal<DateFormat>() {
        @Override
        protected DateFormat initialValue() {
            return new SimpleDateFormat("yyyy-MM-dd");
        }
    };
        ]]>
        </example>
        <priority>1</priority>
    </rule>
</ruleset>
